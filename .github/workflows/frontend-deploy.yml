# .github/workflows/frontend-deploy.yml (OPTIMIZED VERSION)

name: Frontend - Build and Deploy to ECR
on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment to manage"
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      action:
        description: "Action to perform"
        required: true
        default: build-and-push
        type: choice
        options:
          - build-and-push
          - update-digest-only
          - force-rebuild
      auto_merge:
        description: "Auto-merge the GitOps PR"
        required: false
        default: true
        type: boolean

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: app/frontend
    permissions:
      contents: read
      id-token: write  # Required for OIDC
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for change detection
      
      - name: Set environment variables
        run: |
          case "${{ github.event.inputs.env }}" in
            dev)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_DEV }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_DEV }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_DEV }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_DEV }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_DEV }}" >> $GITHUB_ENV
              ;;
            staging)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_STAGING }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_STAGING }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_STAGING }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_STAGING }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_STAGING }}" >> $GITHUB_ENV
              ;;
            prod)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_PROD }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_PROD }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_PROD }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_PROD }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_PROD }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Check for app code changes
        id: check-app-changes
        run: |
          if [ "${{ github.event.inputs.action }}" == "force-rebuild" ]; then
            echo "app_changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Force rebuild requested"
          elif [ "${{ github.event.inputs.action }}" == "update-digest-only" ]; then
            echo "app_changed=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Update digest only - skipping build"
          else
            # Check if app code actually changed
            if git diff --quiet HEAD~1 HEAD -- app/ helm/ Dockerfile* || [ "${{ github.event_name }}" == "repository_dispatch" ]; then
              if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
                echo "app_changed=true" >> $GITHUB_OUTPUT
                echo "ðŸš€ Infrastructure ready - building initial image"
              else
                echo "app_changed=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ No app code changes detected"
              fi
            else
              echo "app_changed=true" >> $GITHUB_OUTPUT
              echo "ðŸ“ App code changes detected"
            fi
          fi

      - name: Configure AWS credentials
        if: ${{ steps.check-app-changes.outputs.app_changed == 'true' || github.event.inputs.action == 'update-digest-only' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Log in to Amazon ECR
        if: ${{ steps.check-app-changes.outputs.app_changed == 'true' || github.event.inputs.action == 'update-digest-only' }}
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        if: ${{ steps.check-app-changes.outputs.app_changed == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        if: ${{ steps.check-app-changes.outputs.app_changed == 'true' }}
        id: meta
        run: |
          SHA_SHORT=$(echo $GITHUB_SHA | cut -c1-7)
          IMAGE_BASE="${{ env.ECR_REPOSITORY_FRONTEND }}"
          TAG="${{ github.run_id }}-${SHA_SHORT}"
          IMAGE_URI="${IMAGE_BASE}:${TAG}"
          
          echo "image_base=$IMAGE_BASE" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "sha_short=$SHA_SHORT" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image with cache
        if: ${{ steps.check-app-changes.outputs.app_changed == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: app/frontend
          push: true
          tags: ${{ steps.meta.outputs.image_uri }}
          cache-from: type=registry,ref=${{ env.ECR_REPOSITORY_FRONTEND }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REPOSITORY_FRONTEND }}:buildcache,mode=max
          platforms: linux/amd64
      
      - name: Capture image digest
        id: digest
        run: |
          if [ "${{ steps.check-app-changes.outputs.app_changed }}" == "true" ]; then
            # Get digest from newly built image
            DIGEST=$(aws ecr describe-images \
              --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
              --region ${{ env.AWS_REGION }} \
              --image-ids imageTag=${{ steps.meta.outputs.tag }} \
              --query 'imageDetails[0].imageDigest' \
              --output text)
            echo "digest=${{ steps.meta.outputs.image_uri }}@${DIGEST}" >> $GITHUB_OUTPUT
            echo "digest_only=${DIGEST}" >> $GITHUB_OUTPUT
            echo "âœ… New image built: ${{ steps.meta.outputs.tag }}"
          else
            # Get latest image from ECR (no build needed)
            LATEST_DIGEST=$(aws ecr describe-images \
              --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
              --region ${{ env.AWS_REGION }} \
              --query 'sort_by(imageDetails,&imagePushedAt)[-1].imageDigest' \
              --output text)
            echo "digest_only=${LATEST_DIGEST}" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Using existing latest image"
          fi
      
      - name: Check if digest changed in GitOps
        id: check-changes
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.env }}
          NEW_DIGEST: ${{ steps.digest.outputs.digest_only }}
        run: |
          rm -rf gitops-repo
          git clone https://x-access-token:${GH_TOKEN}@github.com/${GITOPS_REPO}.git gitops-repo
          cd gitops-repo
          
          CURRENT_DIGEST=$(grep 'digest:' environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml | sed 's/.*digest: "\(.*\)"/\1/')
          
          if [ "$CURRENT_DIGEST" == "$NEW_DIGEST" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "âœ… Digest unchanged: $CURRENT_DIGEST"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ Digest changed: $CURRENT_DIGEST â†’ $NEW_DIGEST"
          fi

      - name: Update GitOps repository
        if: ${{ steps.check-changes.outputs.changed == 'true' }}
        id: create-pr
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.env }}
          NEW_DIGEST: ${{ steps.digest.outputs.digest_only }}
        run: |
          cd gitops-repo
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          BRANCH_NAME="frontend-update-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b "$BRANCH_NAME"
          
          sed -i "s|digest: \"sha256:.*\"|digest: \"${NEW_DIGEST}\"|g" environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml
          git add environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml
          git commit -m "Update frontend digest for ${ENVIRONMENT}: ${NEW_DIGEST}"
          git push origin "$BRANCH_NAME"
          
          # Create PR and capture response
          PR_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITOPS_REPO}/pulls" \
            -d "{\"title\":\"Frontend: Update ${ENVIRONMENT} digest\",\"head\":\"${BRANCH_NAME}\",\"base\":\"main\",\"body\":\"Automated digest update for ${ENVIRONMENT} environment\"}")
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          if [ "$PR_NUMBER" != "null" ] && [ -n "$PR_NUMBER" ]; then
            echo "âœ… Created PR #${PR_NUMBER}"
          else
            echo "âŒ Failed to create PR. Response: $PR_RESPONSE"
            exit 1
          fi
      
      - name: Auto-merge GitOps PR
        if: ${{ steps.check-changes.outputs.changed == 'true' && github.event.inputs.auto_merge == 'true' }}
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          
          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "ðŸ”€ Triggering auto-merge for PR #${PR_NUMBER}..."
            
            curl -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${GITOPS_REPO}/dispatches" \
              -d "{\"event_type\":\"auto-merge-pr\",\"client_payload\":{\"pr_number\":${PR_NUMBER}}}"
            
            echo "âœ… Auto-merge workflow triggered for PR #${PR_NUMBER}"
          else
            echo "âŒ No PR found to auto-merge"
          fi
      
      - name: Build Summary
        run: |
          echo "## ðŸš€ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.env }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "- **App Changed:** ${{ steps.check-app-changes.outputs.app_changed }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Digest Changed:** ${{ steps.check-changes.outputs.changed }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-app-changes.outputs.app_changed }}" == "true" ]; then
            echo "- **New Image:** ${{ steps.meta.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.check-changes.outputs.changed }}" == "true" ]; then
            echo "- **PR Created:** #${{ steps.create-pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Auto-merge:** ${{ github.event.inputs.auto_merge }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Result:** No changes needed - everything up to date âœ…" >> $GITHUB_STEP_SUMMARY
          fi